# 正则表达式

正则表达式，可以归纳为3个括号

## 小括号

用圆括号 **()** 将所有选择项括起来，相邻的选择项之间用 **|** 分隔。**()** 表示捕获分组，同时**()** 会把每个分组里的匹配的值保存起来。

## 中括号

中括号就是进行匹配中括号内的单位字符在，例如`[abc]`那么就会在对应的字符串中匹配a、b、c。

| 元素     | 描述                                                        |
| -------- | ---------------------------------------------------------|
| [^abc]   | 匹配除了包含在中括号的任意字符                              |
| [^a-z]   | 匹配除了包含在中括号指定区间字符的任意字符                  |
| [abc]    | 匹配括号中指定的任意一个字符                                |
| [a-z]    | 匹配括号中指定的任意区间中的任意一个字符                    |





## 大括号

前一个字符出现的个数，

| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |



## 转义字符






| 元素     | 描述                                                        |
| -------- | ---------------------------------------------------------|
| \d       | 匹配数字字符，等同于[0-9]                                   |
|  \D     | 匹配任意非数字                                               |
| \w       | 匹配字符，数字和下划线                                      |
| \W       | 匹配匹配字符，数字和下划线意外的字符                        |
| \s       | 白空格（空格，制表符，新行）                                |
| \S       | 匹配白空格（空格，制表符，新行）意外的字符                  |
|不常见字符 | 结果|
| \a       | 响铃字符（ASCII 7）                                         |
| \c or \C | 匹配ASCII 中的控制字符，例如Ctrl+C                          |
| \D       | 匹配数字以外的字符                                          |
| \e       | Esc (ASCII 9)                                             |
| \f       | 换页符(ASCII 15)                                           |
| \n       | 换行符                                                    |
| \r       | 回车符                                                     |
| \t       | 制表符                                                     |
| \uFFFF   | 匹配Unicode字符的十六进制代码FFFF。例如，欧元符号的代码20AC |
| \v       | 匹配纵向制表符(ASCII 11)                                    |
| \xnn     | 匹配特殊字符，nn代表十六进制的ASCII 码                      |
| .*       | 匹配任意数量的字符（包括0个字符）                           |



## 大小写敏感

-match 大小写不敏感:

```
PS C:\Users\wujiashuai> "hello world" -match "HellO"
True

```

-match 大小写敏感:

```
PS C:\Users\wujiashuai> "hello world" -cmatch "HellO"
False
```



# 匹配

在使用`-match`时候，`$matches`变量会自动被创建。操作符`-match`只会匹配一次正则表达式。

```powershell
PS C:\Users\wujiashuai> $rawtext = "test@pstips.net sent an e-mail that was forwarded to admin@pstips.net."
PS C:\Users\wujiashuai> $rawtext -match "\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b"
True
PS C:\Users\wujiashuai> $matches

Name                           Value
----                           -----
0                              test@pstips.net


```

如何进行多次匹配

```powershell
PS C:\Users\wujiashuai> $rawtext = "test@pstips.net sent an e-mail that was forwarded to admin@pstips.net."
PS C:\Users\wujiashuai> $regex = [regex]"(?i)\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}\b"
PS C:\Users\wujiashuai> $regex.Matches($rawtext)


Groups   : {0}
Success  : True
Name     : 0
Captures : {0}
Index    : 0
Length   : 15
Value    : test@pstips.net

Groups   : {0}
Success  : True
Name     : 0
Captures : {0}
Index    : 53
Length   : 16
Value    : admin@pstips.net
```

给子表达式命名

我们可以使用`?<>`的方式来给匹配的表达式进行命名



获取内容

我们可以通过小括号，获取我们想要的内容

```
PS C:\Users\wujiashuai> "<body background=2>Contents</body>" -match "<([A-Z][A-Z0-9]*)[^>]*>(.*?)</\1>"
True
PS C:\Users\wujiashuai> $result
PS C:\Users\wujiashuai> $matches

Name                           Value
----                           -----
2                              Contents
1                              body
0                              <body background=2>Contents</body>


PS C:\Users\wujiashuai> $matches[2]
Contents
```



# 替换字符串

我们可以通过`-replace`关键词进行字符串的替换。

```
PS C:\Users\wujiashuai> "Mr. Miller and Mrs. Meyer" -replace "(Mr.|Mrs.)", "Our client"
Our client Miller and Our client. Meyer
```

`-replace`支持字符串的替换，因此，我们可以通过正则表达式，进行我们所需要的替换。







# 首行增加

单首行增加

```
PS C:\Users\wujiashuai> $text = @"
>> 这是一段文本，
>> 我想在回复的邮件中引用它，
>> 所以我在每行的开始追加了">" 符号。
>> "@
PS C:\Users\wujiashuai> $text -replace "^", "> "
> 这是一段文本，
我想在回复的邮件中引用它，
所以我在每行的开始追加了">" 符号。
```

每行首位增加

```powershell
PS C:\Users\wujiashuai> $text -replace "(?m)^", "> "
> 这是一段文本，
> 我想在回复的邮件中引用它，
> 所以我在每行的开始追加了">" 符号。
```

